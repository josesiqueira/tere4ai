version: 1
tasks:
  - description: |
      Add an EU→HLEG mapping layer:

        - Define Pydantic models for mapping one EU AI Act "requirement paragraph"
          to zero or more HLEG requirements, including a rationale for each link.
        - Implement a mapping agent (gpt-5-nano) that:
            * takes one EU paragraph + its location (chapter, article, paragraph)
            * chooses relevant HLEG requirements from the canonical seven
            * outputs relevance scores and textual rationales
        - Implement deterministic Neo4j ingestion:
            * create ALIGNS_WITH_HLEG_REQUIREMENT relationships from Paragraph
              nodes (EU side) to HLEGRequirement nodes (HLEG side)
            * store relevance + rationale on the relationship
        - Add a runner script that:
            * selects candidate EU paragraphs (high-impact chapters + “shall/must”)
            * runs the mapping agent over them (async, limited concurrency)
            * ingests mappings into Neo4j.

      This should NOT re-parse the EU AI Act or HLEG; it assumes both are already
      ingested structurally. It only creates cross-source alignment edges.
    changes:
      # -----------------------------------------------------------------------
      # 1) Pydantic models for EU→HLEG mapping
      # -----------------------------------------------------------------------
      - path: models/eu_hleg_mapping.py
        type: create
        content: |
          """
          Pydantic models for mapping EU AI Act requirements to HLEG requirements.

          This module defines:
            - HlegLink: one link from an EU requirement paragraph to a single
              HLEG requirement, with a relevance score and rationale.
            - EuRequirementLocation: deterministic location of the EU paragraph.
            - EuToHlegMapping: the mapping for one EU paragraph (location + links).

          TRUSTWORTHINESS PRINCIPLES:

            - The LLM chooses which HLEG requirements are relevant and provides
              a rationale grounded in both texts.

            - All location metadata (document_id, chapter_number, article_number,
              paragraph_index) is deterministic and provided by the caller.

            - Ingestion into Neo4j is deterministic and idempotent: MERGE on
              Paragraph + HLEGRequirement, MERGE the relationship, SET properties.
          """

          from __future__ import annotations

          from typing import List
          from pydantic import BaseModel, Field


          class HlegLink(BaseModel):
              """
              One link from an EU requirement paragraph to a single HLEG requirement.

              Example:
                - hleg_requirement_id: "technical_robustness_and_safety"
                - relevance: 0.9
                - rationale: "This paragraph imposes robustness obligations ..."
              """
              hleg_requirement_id: str = Field(
                  description=(
                      "ID of the HLEG requirement, e.g. 'technical_robustness_and_safety'. "
                      "Must be one of the canonical seven requirement IDs."
                  )
              )
              relevance: float = Field(
                  ge=0.0,
                  le=1.0,
                  description=(
                      "How strongly this EU paragraph relates to the given HLEG "
                      "requirement, from 0.0 (not related) to 1.0 (very strongly related)."
                  ),
              )
              rationale: str = Field(
                  description=(
                      "Short explanation of WHY this HLEG requirement is relevant, "
                      "grounded in both the EU paragraph and the HLEG requirement "
                      "description."
                  )
              )


          class EuRequirementLocation(BaseModel):
              """
              Deterministic location of an EU AI Act 'requirement paragraph'.

              We do NOT invent IDs here; we use structural location:
                - document_id: e.g. 'eu_ai_act_2024'
                - chapter_number: e.g. 'III'
                - article_number: e.g. '9'
                - paragraph_index: integer index within the article (1-based or 0-based,
                  but must be consistent with the structural ingestion).
              """
              document_id: str = Field(
                  description="ID of the EU AI Act document, e.g. 'eu_ai_act_2024'."
              )
              chapter_number: str = Field(
                  description="Chapter number as string, e.g. 'III'."
              )
              article_number: str = Field(
                  description="Article number as string, e.g. '9'."
              )
              paragraph_index: int = Field(
                  description=(
                      "Paragraph index inside the article (must match the structural "
                      "preprocessing, e.g. 1 for '1.', 2 for '2.', etc.)."
                  )
              )


          class EuToHlegMapping(BaseModel):
              """
              Mapping from one EU requirement paragraph to zero or more HLEG
              requirements.

              This is the OUTPUT of the EU→HLEG mapping agent.

              If 'links' is empty, it means the agent decided that this EU paragraph
              is not meaningfully aligned with any of the seven HLEG requirements.
              """
              location: EuRequirementLocation = Field(
                  description="Structural location of the EU paragraph."
              )
              paragraph_text: str = Field(
                  description="Full text of the EU paragraph being classified."
              )
              links: List[HlegLink] = Field(
                  default_factory=list,
                  description=(
                      "Zero or more links to HLEG requirements, each with "
                      "relevance and rationale."
                  ),
              )


      # -----------------------------------------------------------------------
      # 2) Deps for the mapping agent (deterministic metadata)
      # -----------------------------------------------------------------------
      - path: models/eu_hleg_mapping_deps.py
        type: create
        content: |
          """
          Dependency model for EU→HLEG mapping agent.

          All of these values are deterministic metadata provided by the caller.
          The LLM MUST NOT change them. They are echoed into the output
          EuRequirementLocation.
          """

          from pydantic import BaseModel, Field


          class EuHlegMappingDeps(BaseModel):
              """
              Deterministic metadata for a single EU requirement paragraph
              being mapped to HLEG requirements.
              """
              document_id: str = Field(
                  description="EU AI Act document id, e.g. 'eu_ai_act_2024'."
              )
              chapter_number: str = Field(
                  description="Chapter number as string, e.g. 'III'."
              )
              article_number: str = Field(
                  description="Article number as string, e.g. '9'."
              )
              paragraph_index: int = Field(
                  description=(
                      "Paragraph index inside the article (consistent with structural "
                      "preprocessing)."
                  )
              )


      # -----------------------------------------------------------------------
      # 3) EU→HLEG mapping agent (gpt-5-nano)
      # -----------------------------------------------------------------------
      - path: agent_eu_hleg_mapping.py
        type: create
        content: |
          """
          EU→HLEG Mapping Agent

          This agent receives:
            - One EU AI Act requirement paragraph (text)
            - Its structural location (chapter, article, paragraph_index) via deps
            - The canonical list of seven HLEG requirements (IDs + names + brief descriptions)
              baked into the instructions

          It outputs:
            - EuToHlegMapping, containing:
                * location (echoed from deps)
                * paragraph_text
                * zero or more HlegLink entries, each with:
                    - hleg_requirement_id
                    - relevance score (0.0–1.0)
                    - rationale (explanation of why it's related)

          TRUSTWORTHINESS PRINCIPLES:

            - The LLM may decide that a paragraph is NOT meaningfully aligned with
              any HLEG requirement (links = []).

            - The LLM must ONLY use the seven canonical HLEG requirement IDs.

            - Rationales are REQUIRED: each link must explain why, grounded in
              both texts (EU paragraph + HLEG requirement description).

            - Ingestion to Neo4j (ingest_eu_hleg_mapping.py) is deterministic and
              has no LLM involvement.
          """

          from dotenv import load_dotenv
          from pydantic_ai import Agent
          from pydantic_ai.models.openai import OpenAIChatModel

          from models.eu_hleg_mapping import EuToHlegMapping
          from models.eu_hleg_mapping_deps import EuHlegMappingDeps

          # Load environment variables for OPENAI_API_KEY
          load_dotenv()

          # Model configuration: use gpt-5-nano (large context, cost-effective)
          model = OpenAIChatModel(
              model_name="gpt-5-nano",
          )


          eu_hleg_mapping_agent = Agent[EuHlegMappingDeps, EuToHlegMapping](
              model,
              deps_type=EuHlegMappingDeps,
              output_type=EuToHlegMapping,
              instructions="""
              You are a legal alignment agent.

              Your task is to read ONE requirement paragraph from the EU AI Act
              and decide how it relates (if at all) to the seven HLEG requirements
              of Trustworthy AI.

              INPUT:
                - You will receive:
                    * One EU AI Act paragraph (text)
                    * Structural location via deps:
                        - document_id (e.g. 'eu_ai_act_2024')
                        - chapter_number (e.g. 'III')
                        - article_number (e.g. '9')
                        - paragraph_index (e.g. 1)
                - You also know the canonical seven HLEG requirements:

                    ID: human_agency_and_oversight
                      Name: Human agency and oversight
                      Summary: Humans remain in charge; AI supports human autonomy
                               and meaningful oversight, including the ability to
                               intervene, override and understand decisions.

                    ID: technical_robustness_and_safety
                      Name: Technical robustness and safety
                      Summary: AI should be resilient, secure, reliable, with
                               fallback plans and mechanisms to avoid or mitigate
                               harm.

                    ID: privacy_and_data_governance
                      Name: Privacy and data governance
                      Summary: AI must respect privacy and data protection, with
                               proper data quality, access control, and governance.

                    ID: transparency
                      Name: Transparency
                      Summary: AI decisions should be understandable, with
                               traceability, explainability, and clear communication
                               about the system's nature and limitations.

                    ID: diversity_non_discrimination_and_fairness
                      Name: Diversity, non-discrimination and fairness
                      Summary: AI should avoid unfair bias, support equal access,
                               and respect diversity and inclusion.

                    ID: societal_and_environmental_well_being
                      Name: Societal and environmental well-being
                      Summary: AI should benefit society at large, support
                               sustainability, and avoid undermining social or
                               environmental welfare.

                    ID: accountability
                      Name: Accountability
                      Summary: There should be mechanisms to ensure responsibility,
                               auditability, redress, and oversight across the AI
                               system's lifecycle.

              OUTPUT:
                - You must produce a EuToHlegMapping with:
                    * location: echo deps EXACTLY
                    * paragraph_text: echo the EU paragraph text you received
                    * links: zero or more HlegLink entries

              RULES FOR LINKS:

                1. HLEG REQUIREMENT IDs
                   - hleg_requirement_id MUST be one of the seven IDs listed above.
                   - NEVER invent new requirement IDs.

                2. RELEVANCE SCORE
                   - relevance is a float from 0.0 to 1.0.
                   - Use:
                       ~0.8–1.0  for strong, direct alignment
                       ~0.4–0.7  for partial/indirect relevance
                       <0.4      rarely needed; prefer omitting low-relevance links.

                3. RATIONALE (MOST IMPORTANT)
                   - Each link MUST include a short rationale explaining why this
                     HLEG requirement is relevant.
                   - The rationale MUST:
                       * reference the EU paragraph's obligations or prohibitions,
                       * reference the HLEG requirement's main idea,
                       * be grounded in the text (no speculation).
                   - Example style:
                     "This paragraph obliges providers to implement robust risk
                      management and post-market monitoring, which directly supports
                      technical robustness and safety."

                4. NUMBER OF LINKS
                   - Usually 0–3 links per paragraph is enough.
                   - If the paragraph does not meaningfully relate to any of the
                     seven HLEG requirements, return an empty 'links' list.

                5. WHEN TO RETURN NO LINKS
                   - If the paragraph is purely about:
                       * definitions,
                       * cross-references,
                       * procedural details that do not express substantive AI
                         requirements,
                     then you may return 'links': [].

              OUTPUT STYLE:
                - Strictly follow the EuToHlegMapping schema.
                - No extra commentary outside the structured output.

              Remember: your job is not to restate the entire law or guidelines,
              but to indicate which HLEG requirements best capture the spirit
              of this particular EU obligation, with a clear rationale.
              """,
          )


      # -----------------------------------------------------------------------
      # 4) Deterministic Neo4j ingestion for EU→HLEG mappings
      # -----------------------------------------------------------------------
      - path: ingest_eu_hleg_mapping.py
        type: create
        content: |
          """
          Deterministic Neo4j ingestion for EU→HLEG mappings.

          This module takes a EuToHlegMapping (output from agent_eu_hleg_mapping.py)
          and writes relationships from the relevant EU paragraph to HLEGRequirement
          nodes.

          Graph pattern (assumed):

            (d:Document {id: document_id})
              -[:HAS_CHAPTER]->(c:Chapter {number: chapter_number})
              -[:HAS_ARTICLE]->(a:Article {number: article_number})
              -[:HAS_PARAGRAPH]->(p:Paragraph {index: paragraph_index})

            (h:HLEGRequirement {id: hleg_requirement_id})

            (p)-[:ALIGNS_WITH_HLEG_REQUIREMENT {
                  relevance,
                  rationale,
                  source,
                  mapped_at
                }]->(h)

          TRUSTWORTHINESS PRINCIPLES:

            - This module has NO LLM calls. It is deterministic.

            - It does not invent document structure; it assumes the EU AI Act
              and HLEG requirements have already been ingested using the
              structural pipelines.

            - MERGE is used for the relationship to avoid duplicates. Properties
              (relevance, rationale, source, mapped_at) can be updated on reruns.
          """

          from typing import Optional

          from neo4j import Driver
          from config.neo4j_config import get_neo4j_driver
          from models.eu_hleg_mapping import EuToHlegMapping, HlegLink


          def ingest_eu_hleg_mapping(
              mapping: EuToHlegMapping,
              source: str = "eu_to_hleg_mapping_agent_v1",
          ) -> None:
              """
              Ingest a single EuToHlegMapping into Neo4j.

              If mapping.links is empty, nothing is written.

              Args:
                  mapping: EuToHlegMapping instance from the mapping agent.
                  source: Short string identifying the mapping pipeline version.
              """
              if not mapping.links:
                  # Nothing to ingest for this paragraph
                  return

              loc = mapping.location

              with get_neo4j_driver() as driver:
                  for link in mapping.links:
                      _create_alignment_relationship(
                          driver=driver,
                          document_id=loc.document_id,
                          chapter_number=loc.chapter_number,
                          article_number=loc.article_number,
                          paragraph_index=loc.paragraph_index,
                          link=link,
                          source=source,
                          paragraph_text=mapping.paragraph_text,
                      )


          def _create_alignment_relationship(
              driver: Driver,
              document_id: str,
              chapter_number: str,
              article_number: str,
              paragraph_index: int,
              link: HlegLink,
              source: str,
              paragraph_text: str,
          ) -> None:
              """
              Create or merge one ALIGNS_WITH_HLEG_REQUIREMENT relationship between
              a Paragraph and a HLEGRequirement.
              """
              cypher = """
              MATCH (d:Document {id: $document_id})
                    -[:HAS_CHAPTER]->(c:Chapter {number: $chapter_number})
                    -[:HAS_ARTICLE]->(a:Article {number: $article_number})
                    -[:HAS_PARAGRAPH]->(p:Paragraph {index: $paragraph_index})
              MATCH (h:HLEGRequirement {id: $hleg_requirement_id})
              MERGE (p)-[r:ALIGNS_WITH_HLEG_REQUIREMENT]->(h)
              SET r.relevance = $relevance,
                  r.rationale = $rationale,
                  r.source    = $source,
                  r.mapped_at = datetime(),
                  r.paragraph_text_snapshot = $paragraph_text
              """

              driver.execute_query(
                  cypher,
                  document_id=document_id,
                  chapter_number=chapter_number,
                  article_number=article_number,
                  paragraph_index=paragraph_index,
                  hleg_requirement_id=link.hleg_requirement_id,
                  relevance=link.relevance,
                  rationale=link.rationale,
                  source=source,
                  paragraph_text=paragraph_text,
              )


      # -----------------------------------------------------------------------
      # 5) Runner: select candidate EU paragraphs and map them to HLEG
      # -----------------------------------------------------------------------
      - path: run_map_eu_to_hleg.py
        type: create
        content: |
          """
          Map selected EU AI Act paragraphs to HLEG requirements.

          This script:

            1. Connects to Neo4j and selects candidate EU paragraphs that:
                 - belong to high-impact chapters (e.g. II and III)
                 - contain normative verbs such as 'shall', 'must', 'prohibited'
            2. For each candidate paragraph:
                 - Calls eu_hleg_mapping_agent (gpt-5-nano)
                 - Receives EuToHlegMapping with HlegLink entries and rationales
            3. Ingests the mappings into Neo4j using ingest_eu_hleg_mapping()

          TRUSTWORTHINESS / SCOPE:

            - We do NOT classify every sentence in the EU AI Act.
              Instead, we focus on paragraphs that are likely to contain
              substantive requirements, especially in high-risk chapters.

            - This is a v0 heuristic:
                * Chapter IN ['II', 'III'] (can be adjusted)
                * Paragraph text matches '(?i).*\\b(shall|must|prohibited|shall not)\\b.*'

            - For your PhD, this is defensible as:
                'We focus alignment on the parts of the Act that express
                 clearly normative obligations, especially for high-risk AI.'
          """

          import asyncio
          import re
          from typing import List

          from dotenv import load_dotenv

          from config.neo4j_config import execute_query, verify_connection
          from agent_eu_hleg_mapping import eu_hleg_mapping_agent
          from models.eu_hleg_mapping import EuRequirementLocation
          from models.eu_hleg_mapping_deps import EuHlegMappingDeps
          from ingest_eu_hleg_mapping import ingest_eu_hleg_mapping


          # Load env (OPENAI_API_KEY, Neo4j config)
          load_dotenv()


          NORMATIVE_REGEX = r"(?i).*\\b(shall|must|prohibited|shall not)\\b.*"


          def fetch_candidate_paragraphs(document_id: str) -> List[dict]:
              """
              Select candidate EU AI Act paragraphs for mapping.

              Heuristic:
                - Limit to chapters II and III (can be extended).
                - Paragraph text contains 'shall', 'must', 'prohibited', 'shall not'
                  (case-insensitive).

              Returns a list of dicts with:
                - chapter_number
                - article_number
                - paragraph_index
                - paragraph_text
              """
              cypher = """
              MATCH (d:Document {id: $document_id})
                    -[:HAS_CHAPTER]->(c:Chapter)-[:HAS_ARTICLE]->(a:Article)
                    -[:HAS_PARAGRAPH]->(p:Paragraph)
              WHERE c.number IN ['II', 'III']
                AND p.text =~ $normative_regex
              RETURN c.number AS chapter_number,
                     a.number AS article_number,
                     p.index  AS paragraph_index,
                     p.text   AS paragraph_text
              ORDER BY c.number, a.number, p.index
              """

              records = execute_query(
                  cypher,
                  document_id=document_id,
                  normative_regex=NORMATIVE_REGEX,
              )

              results: List[dict] = []
              for rec in records:
                  results.append(
                      {
                          "chapter_number": rec["chapter_number"],
                          "article_number": rec["article_number"],
                          "paragraph_index": rec["paragraph_index"],
                          "paragraph_text": rec["paragraph_text"],
                      }
                  )
              return results


          async def process_one_paragraph(
              document_id: str,
              chapter_number: str,
              article_number: str,
              paragraph_index: int,
              paragraph_text: str,
          ):
              """
              Run the mapping agent for one paragraph and ingest the result.
              """
              deps = EuHlegMappingDeps(
                  document_id=document_id,
                  chapter_number=chapter_number,
                  article_number=str(article_number),
                  paragraph_index=int(paragraph_index),
              )

              # Prompt: keep it simple; instructions embed the HLEG requirements
              prompt = (
                  "Classify the following EU AI Act paragraph against the seven "
                  "HLEG requirements of Trustworthy AI.\n\n"
                  "Paragraph text:\n"
                  f"{paragraph_text}"
              )

              result = await eu_hleg_mapping_agent.run(prompt, deps=deps)
              mapping = result.output
              ingest_eu_hleg_mapping(mapping)


          async def main():
              """
              Entry point: map candidate EU AI Act paragraphs to HLEG requirements.
              """
              DOCUMENT_ID = "eu_ai_act_2024"  # adjust if you used a different id

              print("Prerequisites:")
              print("  ✓ OPENAI_API_KEY in .env file")
              print("  ✓ Neo4j running and populated with:")
              print("      - EU AI Act structure (Document/Chapter/Article/Paragraph)")
              print("      - HLEG requirements (HLEGRequirement nodes)")
              print()

              if not verify_connection():
                  print("❌ Neo4j connection failed. Check config.neo4j_config and Docker.")
                  return

              print("✓ Neo4j connection verified.\n")

              print("=" * 70)
              print("EU→HLEG MAPPING - HIGH-IMPACT PARAGRAPHS")
              print("=" * 70)
              print(
                  "Selecting candidate paragraphs from EU AI Act (chapters II & III,\n"
                  "containing 'shall', 'must', 'prohibited', 'shall not').\n"
              )

              candidates = fetch_candidate_paragraphs(DOCUMENT_ID)
              print(f"Found {len(candidates)} candidate paragraphs.\n")

              if not candidates:
                  print("⚠️ No candidates found. Check document_id or structural ingestion.")
                  return

              # Process paragraphs sequentially or with small concurrency
              # (here we keep it simple: sequential processing for transparency)
              for i, c in enumerate(candidates, start=1):
                  print(
                      f"[{i}/{len(candidates)}] "
                      f"Chapter {c['chapter_number']}, Article {c['article_number']}, "
                      f"Paragraph {c['paragraph_index']}..."
                  )
                  try:
                      await process_one_paragraph(
                          document_id=DOCUMENT_ID,
                          chapter_number=c["chapter_number"],
                          article_number=str(c["article_number"]),
                          paragraph_index=int(c["paragraph_index"]),
                          paragraph_text=c["paragraph_text"],
                      )
                  except Exception as e:
                      print(f"  ❌ Mapping failed for this paragraph: {e}")
                      continue

              print()
              print("=" * 70)
              print("✓ EU→HLEG MAPPING COMPLETE")
              print("=" * 70)
              print()
              print("You can now explore alignment edges in Neo4j, e.g.:")
              print("  MATCH (p:Paragraph)-[r:ALIGNS_WITH_HLEG_REQUIREMENT]->(h:HLEGRequirement)")
              print("  RETURN p, r, h LIMIT 25;")
              print()
              print("Each relationship r carries:")
              print("  - r.relevance (0.0–1.0)")
              print("  - r.rationale (LLM explanation)")
              print("  - r.source (pipeline id)")
              print("  - r.mapped_at (timestamp)")
              print()
              print("These rationales are crucial for your PhD story on trustworthiness: ")
              print("they make the LLM's classification inspectable and auditable.")


          if __name__ == "__main__":
              asyncio.run(main())
